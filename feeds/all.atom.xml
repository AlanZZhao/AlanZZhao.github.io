<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Alan Zhao</title><link href="http://alanzzhao.com/" rel="alternate"></link><link href="http://alanzzhao.com/feeds/all.atom.xml" rel="self"></link><id>http://alanzzhao.com/</id><updated>2016-08-28T08:44:00-04:00</updated><entry><title>testing_comments</title><link href="http://alanzzhao.com/testing_comments.html" rel="alternate"></link><updated>2016-08-28T08:44:00-04:00</updated><author><name>Alan Zhao</name></author><id>tag:alanzzhao.com,2016-08-28:testing_comments.html</id><summary type="html">&lt;p&gt;blah blah&lt;/p&gt;
</summary></entry><entry><title>Thoughts on Coursera's Algorithms and Data Structures - Part 1</title><link href="http://alanzzhao.com/thoughts-on-coursera's-algorithms-and-data-structures---part-1.html" rel="alternate"></link><updated>2016-07-23T22:16:00-04:00</updated><author><name>Alan Zhao</name></author><id>tag:alanzzhao.com,2016-07-23:thoughts-on-coursera's-algorithms-and-data-structures---part-1.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Motivation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After spending the past three years largely independently learning programming with a &amp;quot;just make it work&amp;quot; mentality, I
decided in January 2016 to formalize my knowledge with an actual course. Massive open online course companies like
&lt;a class="reference external" href="https://www.coursera.com/"&gt;Coursera&lt;/a&gt;, &lt;a class="reference external" href="https://edx.com/"&gt;EdX&lt;/a&gt;, and &lt;a class="reference external" href="http://codecademy.com"&gt;Codecademy&lt;/a&gt; offer lots of programming courses, but the majority of these are introductory-level or
application-specific (like data-analysis with Python or web development with Ruby). I wanted something that would be a
general &amp;quot;next level&amp;quot; course but also one that I could do with Python. I talked to software engineer friends and looked at some universities' syllabi and found that the Data Structures and Algorithms topics were the standard 2nd or 3rd course.&lt;/p&gt;
&lt;p&gt;Coursera had an entire 6 month &lt;a class="reference external" href="https://www.coursera.org/specializations/data-structures-algorithms"&gt;Data Structures and Algorithms specialization&lt;/a&gt; and it (mostly) fit before my graduate
school began so signed up. I liked that the class would be going in-depth, with 5 separate courses and also a &amp;quot;capstone&amp;quot;
applied project. It also allowed for numerous languages (Ruby, Python 2&amp;amp;3, C, C++, Java) but only officially supported Java, C and Python 3 with starter files. To motivate myself further to actually complete the course, I paid the ~400 dollars to get the course verified (and for the nifty certificates on my linkedin).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Course Structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unsurprisingly, the course philosophy is learning through doing. You watch 1-2 hours of lectures, with some embedded quizzes, and then code solutions to the problem set. The solutions are submitted to a cold, inhuman grader that compiles your code and checks against 15+ test cases. There's also a discussion session to post questions and answers. The homeworks are well designed and closely follow the lectures. I did find that the coursework typically took double the amount of time estimated (6-8 vs 3-4 hours). The courses are pre-recorded and each one follows a set session. Missing one is fine as you can restart it, but you only have one full year from payment to finish the 6-month specialization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Learnings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Testing&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Learning how to design test cases and automate them was the most valuable takeaway from the course. The test cases are hidden beyond the first 3, so you need to become adept at implementing test cases to pass. Running tests manually becomes incredibly annoying, so I got much more comfortable with the assert statement. The course introduced me to the idea of testing corner cases with manually created cases, and then automated testing with random inputs (and brute-force calculated correct outputs).&lt;/p&gt;
&lt;p&gt;Once I saw the time and headache save from rigorous testing, I started implementing testing at work. Prior to the course, my code base utilized integration testing not unit testing. Afterwards, I made it a team project to go back and write unit tests and the amount of blocker issues we uncovered was incredible.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pseudocode Literacy&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I never read formal pseudocode before - shocking, I know. Pseudocode was intimidating, and I just avoided it. You can't avoid it in this specialization though: the course is language-agnostic so the lingua franca is pseudocode. Every lecture has pseudocode, so every week involves translating what's conceptually laid out into code. This skill greatly increased my ability to pick up technical documentation on code-agnostic places like wikipedia.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Immediate Applicability&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Algorithms and Data Structures sounded more like conceptual learnings than something helpful in my day to day at work. I was wrong about that. Learning &amp;quot;memoization&amp;quot; (giving your program memory of past results) as part of dynamic programming immediately gave me insight on how to speed up a database call that made redundant calculations. Implementing it took less than two days and cut down a query run 10x/day down from 5-10 minutes to 1-2 minutes. Sounds simple, but I had never heard of the concept before. However, because the class is general, not applications focused, you're going to need to figure out the applications yourself. I still haven't figured out applciations for all those graph algorithms or self-balancing trees.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So What's Missing?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Declining Enrollment&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The course started off with high participation that gradually declined as we advanced through courses. In the first course, Algorithmic Toolkit, we had several thousand students across the world according to a live world map with student populations. The forums were active; every question I had while doing the homeworks was already asked and answered on the forums.&lt;/p&gt;
&lt;p&gt;It was a different story by the third course, Algorithms on Strings. From forum activity, I estimate only several hundred people are taking this course. One question that I posted only got &amp;lt;10 views after several days with no response. Coincidentally, the world map showing classmate numbers is also no longer on the course side. I wish I had taken a screenshot of the original world map with student populations to prove this! The enrollment decline is expected from the increasing difficulty of the course and the extended commitment to stay on track. To be honest, I'm one of those students who's fallen behind. After completing the first two courses, I wasn't able to complete Algorithms on Strings on time and am now doing it with the second session. I hope more students regroup with me; the active discussion is key to learning.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Python's Limitations&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I love Python because it's an abstracted high-level language. Unfortunately, this makes it difficult to implement many of the data structures because they don't exist natively in the language. Take the Python list object: it's easy to understand and use to build applications because of it's flexibility. The downside is that you need to simplify it or use it other ways to use it as a linked list or queue structure.&lt;/p&gt;
&lt;p&gt;This lack of native support for &amp;quot;low-level&amp;quot; Python also meant a greater lack of resources than what I expected. Most supplemental resources I found outside the class were exclusively C or Java, so I relied heavily on reading pseudocode and stack overflow Python questions. A great find was this free Data Structures and Algorithms textbook written in Python. Roughly 70% of the first two courses was covered in these books.&lt;/p&gt;
&lt;p&gt;After all that's said and done, I do thank Coursera for including Python as a supported course. I would never have taken on this course if it required learning a whole new language.&lt;/p&gt;
&lt;p&gt;Hope this was helpful. Now on to finishing Algorithms on Strings!&lt;/p&gt;
</summary><category term="python"></category><category term="learning"></category><category term="coursera"></category><category term="algorithms"></category><category term="data-structures"></category></entry><entry><title>National Parks Historical Attendence</title><link href="http://alanzzhao.com/national-parks-historical-attendence.html" rel="alternate"></link><updated>2016-06-25T11:13:00-04:00</updated><author><name>Alan Zhao</name></author><id>tag:alanzzhao.com,2016-06-25:national-parks-historical-attendence.html</id><summary type="html">&lt;embed&gt;
    &lt;script type='text/javascript' src='https://public.tableau.com/javascripts/api/viz_v1.js'&gt;&lt;/script&gt;&lt;div class='tableauPlaceholder' style='width: 1020px; height: 1033px;'&gt;&lt;noscript&gt;&lt;a href='#'&gt;&lt;img alt='National Parks through Forty Years of Attendance Data ' src='https:&amp;#47;&amp;#47;public.tableau.com&amp;#47;static&amp;#47;images&amp;#47;Na&amp;#47;NationalParksAttendance&amp;#47;Story&amp;#47;1_rss.png' style='border: none' /&gt;&lt;/a&gt;&lt;/noscript&gt;&lt;object class='tableauViz' width='1020' height='800' style='display:none;'&gt;&lt;param name='host_url' value='https%3A%2F%2Fpublic.tableau.com%2F' /&gt; &lt;param name='site_root' value='' /&gt;&lt;param name='name' value='NationalParksAttendance&amp;#47;Story' /&gt;&lt;param name='tabs' value='no' /&gt;&lt;param name='toolbar' value='yes' /&gt;&lt;param name='static_image' value='https:&amp;#47;&amp;#47;public.tableau.com&amp;#47;static&amp;#47;images&amp;#47;Na&amp;#47;NationalParksAttendance&amp;#47;Story&amp;#47;1.png' /&gt; &lt;param name='animate_transition' value='yes' /&gt;&lt;param name='display_static_image' value='yes' /&gt;&lt;param name='display_spinner' value='yes' /&gt;&lt;param name='display_overlay' value='yes' /&gt;&lt;param name='display_count' value='yes' /&gt;&lt;param name='showTabs' value='y' /&gt;&lt;/object&gt;&lt;/div&gt;
&lt;/embed&gt;&lt;p&gt;&lt;strong&gt;About the Visualization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I've been a huge fan of national parks; one of my goals is to visit all 60+ of them (so far only halfway there). When I
saw that Tableau was sponsorsing a visualization competition at the &lt;a class="reference external" href="http://www.dogooddata.com/"&gt;2016 DoGoodData conference&lt;/a&gt;, doing something with
National Parks came to mind. The competition rules were broad: pick a social sector data set and tell a story with it.
I did a bit of digging on the &lt;a class="reference external" href="https://www.nps.gov/"&gt;National Park Service site&lt;/a&gt; and saw they have a significant amount of data collected on
a &lt;a class="reference external" href="https://irma.nps.gov/Stats/"&gt;statistics subsection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately the data was separated by every park and in some report-style Excel spreadsheets. I used Python to scrape, clean and aggregate the different pages data. Once I built the full dataset, I started exploring the data. I was
curious to see how attendance varied by park, how it grew over time, and how cyclical it was. My own experience visiting
parks had given me intuition about these trends (ie Grand Canyon is really popular compared to Bryce Canyon, nobody
visits Acadia in the Maine winter). These guiding questions each drove what went into each page.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Page One - Attendance by Park&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Building the map of NPS sites with their dot size determined by attendance was straightforward, but the visualization
looked bland initially. I really wanted to get some kind of image of the parks - after all people love and recognize
parks for their imagery, not their data points. I wasn't sure where I could find a data source of iconic photos for each
park. I considered grabbing each park's wikipedia page, but found that their image quality varied and in some cases
their page didn't have a photo yet. I ended up with a neat solution - use each park's official NPS site. Each site had a
high-quality iconic image and I could embed the image directly into Tableau using Tableau's website embed feature. A bit
of tinkering with the dimensions and having Tableau load the page at the image's HTML class div and voila, an on demand
library of curated images.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Page Two - Visitation Growth Over 40 Years&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Parks have gotten much popular since data started getting collected in 1979; almost doubling. It turned out that the
growth is concentrated in a few parks in particular: Zion, Yosemite, and Grand Canyon.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Page Three - Seasonality of Park Attendance&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Each park has some sort of seasonality, here you can see what each particular park's looks like. Most follow a trend of
high attendance in summer (nice weather plus summer break) but several parks diverge from this. Some are obvious; Death
Valley has almost no visitation in the summer. Others I'm not sure about; Great Smoky Mountains peaks again in the fall
(maybe people checking out the autumn leaves?)&lt;/p&gt;
&lt;p&gt;I was pleased with what came out, but it still could use a bit of polish. Overall, the data collection and visualization
building took a few days as a side project. Maybe I'll write an in-depth analysis of the data in a future blog post
with a cleaner visualization.&lt;/p&gt;
</summary><category term="data visualization"></category><category term="tableau"></category><category term="social sector"></category></entry></feed>